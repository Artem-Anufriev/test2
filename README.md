# test2

Задание 2

Объясните почему блок "Work 2" не выполняется?
1. let serialQueue = DispatchQueue(label: "com.foo.bar")
2. serialQueue.async {
3.      print("work 1")
4.      serialQueue.sync {
5.          print("work 2")
6.      }
7. }

В первой строке кода создается экземпляр последовательной (serial) очереди. Из теории многопоточности в Swift следует, что на последовательной очереди завершение замыканий происходит строго в том порядке, в каком они поступают на выполнение, другими словами, на последовательной очереди в любой текущий момент времени выполняется только одно задание. Кроме того, асинхронная функция async, в противоположность функции sync, возвращает управление на текущую очередь немедленно после запуска задания на выполнение, не ожидая его завершения. Таким образом, асинхронная функция async не блокирует выполнение заданий на текущей очереди serialQueue, и вызов (4) становится возможным. Однако, синхронная функция sync возвращает управление на текущую очередь только после полного завершения задания, тем самым блокируя текущую очередь serialQueue, где уже выполняется задание и вызывая ошибку.

Кроме того, в процессе отладки данного кода в Xcode было выяснено, что в данном контексте библиотека LIBDISPATCH, реализующая методы GCD, зарегистрировала ошибку о некорректном использовании очереди отправки: "BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread", т.е. dispatch_sync вызывается в очереди, уже принадлежащей текущему потоку, что подтверждает вышенаписанные выводы.

Проблема может быть разрешена путем создания экземпляра параллельной очереди, вместо последовательной, в первой строке кода
1. let Queue = DispatchQueue(label: "com.foo.bar", attributes: .concurrent),

Либо выполнить замыкание (5) асинхронно

4. serialQueue.async,

Однако это может противоречить задачам, которые требуется выполнить разработчику.

Отзыв:

+ Очень подробно объяснил.
